/* Generated by Opal 0.8.0.rc2 */
(function(Opal) {
  Opal.dynamic_require_severity = "error";
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs(['$split', '$!', '$empty?', '$=~', '$first', '$index', '$raise', '$==', '$[]', '$shift', '$nil?', '$map', '$include?', '$<<', '$has_key?', '$[]=', '$flatten']);
  return (function($base) {
    var self = $module($base, 'Getopt');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base, $super) {
      function $Std(){};
      var self = $Std = $klass($base, $super, 'Std', $Std);

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $Error(){};
        var self = $Error = $klass($base, $super, 'Error', $Error);

        var def = self.$$proto, $scope = self.$$scope;

        return nil;
      })(self, $scope.get('StandardError'));

      Opal.cdecl($scope, 'VERSION', "1.4.2");

      return (Opal.defs(self, '$getopts', function(switches) {
        var $a, $b, $c, TMP_1, $d, self = this, args = nil, hash = nil, first = nil, rest = nil, pos = nil, temp_args = nil, err = nil;

        args = switches.$split(/ */);
        hash = $hash2([], {});
        while ((($b = ($c = $scope.get('ARGV')['$empty?']()['$!'](), $c !== false && $c !== nil ?$scope.get('ARGV').$first()['$=~'](/^-(.)(.*)/) : $c)) !== nil && (!$b.$$is_boolean || $b == true))) {
        $b = [(($c = $gvars['~']) === nil ? nil : $c['$[]'](1)), (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))], first = $b[0], rest = $b[1];
        pos = switches.$index(first);
        if (pos !== false && pos !== nil) {
          } else {
          self.$raise($scope.get('Error'), "invalid option '" + (first) + "'")
        };
        if (args['$[]']($rb_plus(pos, 1))['$=='](":")) {
          $scope.get('ARGV').$shift();
          if ((($b = rest['$empty?']()) !== nil && (!$b.$$is_boolean || $b == true))) {
            rest = $scope.get('ARGV').$shift();
            if ((($b = ((($c = rest['$nil?']()) !== false && $c !== nil) ? $c : rest['$empty?']())) !== nil && (!$b.$$is_boolean || $b == true))) {
              self.$raise($scope.get('Error'), "missing argument for '-" + (args['$[]'](pos)) + "'")};
            temp_args = ($b = ($c = args).$map, $b.$$p = (TMP_1 = function(e){var self = TMP_1.$$s || this;
if (e == null) e = nil;
            return "-" + (e)}, TMP_1.$$s = self, TMP_1), $b).call($c);
            if ((($b = ((($d = temp_args['$include?'](rest)) !== false && $d !== nil) ? $d : temp_args['$include?'](rest['$[]']($range(1, -1, false))))) !== nil && (!$b.$$is_boolean || $b == true))) {
              err = "cannot use switch '" + (rest) + "' as argument ";
              err['$<<']("to another switch");
              self.$raise($scope.get('Error'), err);};
            if ((($b = hash['$has_key?'](first)) !== nil && (!$b.$$is_boolean || $b == true))) {
              hash['$[]='](first, [hash['$[]'](first), rest].$flatten())
              } else {
              hash['$[]='](first, rest)
            };
          } else if ((($b = ((($d = args['$include?'](rest)) !== false && $d !== nil) ? $d : args['$include?'](rest['$[]']($range(1, -1, false))))) !== nil && (!$b.$$is_boolean || $b == true))) {
            err = "cannot use switch '" + (rest) + "' as argument ";
            err = $rb_plus(err, "to another switch");
            self.$raise($scope.get('Error'), err);};
          } else {
          hash['$[]='](first, true);
          if ((($b = rest['$empty?']()) !== nil && (!$b.$$is_boolean || $b == true))) {
            $scope.get('ARGV').$shift()
            } else {
            $scope.get('ARGV')['$[]='](0, "-" + (rest))
          };
        };};
        return hash;
      }), nil) && 'getopts';
    })(self, null)
  })(self)
})(Opal);
